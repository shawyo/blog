{"meta":{"title":"Shaw Blog","subtitle":null,"description":null,"author":"Shaw","url":"http://nicebp.com"},"pages":[{"title":"","date":"2022-01-12T07:29:47.982Z","updated":"2022-01-12T07:29:47.982Z","comments":true,"path":"404.html","permalink":"http://nicebp.com/404.html","excerpt":"","text":""},{"title":"Categories","date":"2022-01-12T07:29:47.988Z","updated":"2022-01-12T07:29:47.988Z","comments":true,"path":"categories/index.html","permalink":"http://nicebp.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-12-06T06:53:39.000Z","updated":"2022-01-12T07:29:47.987Z","comments":false,"path":"about/index.html","permalink":"http://nicebp.com/about/index.html","excerpt":"","text":"&#123; name: 'Shaw' age: 29, gender: '男', profession: 'Web Developer &amp; Designer', experience: '6年', address: '浙江省杭州市', education: '大专', github: 'https://github.com/shawyo', blog: 'http://seanyo.gitee.io/blog/', email: 'yaoxiaosir@qq.com', skills: [ ['Html5', 'Javascript', 'CSS3', 'ES6+', 'NodeJS', 'TypeScript'], ['Webpack', 'npm'], ['Less','Sass'], ['Git', 'SVN'], ['Vue2.x', 'Vue3.x', 'Vue Router', 'Vuex', 'Echarts', 'MockJs', 'AMap JS', 'BMap JS', 'APICloud', 'jQuery', '微信小程序', '微信公众号开发'], ['Ant Design', 'iview', 'Element-ui', 'Vant', 'Bootstrap', 'Weui'], ['WordPress', 'Discuz', 'Hexo', 'vuepress'], ['平面设计', 'UI设计'] ], devTools: [ ['Visual Studio Code', 'Atom', 'Brackets'], ['Chrome DevTools', 'FireBug'], ['TortoiseSVN', 'Git'], ['NodeJs', 'phpStudy', 'XAMPP'], ], softWare: [ 'Adobe Animate', 'PhotoShop', 'Illustrator', 'skecth', 'Axure', 'MindManager' ]&#125;"},{"title":"Tags","date":"2022-01-12T07:29:48.071Z","updated":"2022-01-12T07:29:48.071Z","comments":true,"path":"tags/index.html","permalink":"http://nicebp.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TypeScript 泛型","slug":"TypeScript-泛型","date":"2019-01-29T03:07:22.000Z","updated":"2022-01-12T07:29:47.984Z","comments":true,"path":"2019/01/29/TypeScript-泛型/","link":"","permalink":"http://nicebp.com/2019/01/29/TypeScript-泛型/","excerpt":"指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。","text":"指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。 泛型 Generics引入 下面创建一个函数, 实现功能: 根据指定的数量 count 和数据 value , 创建一个包含 count 个 value 的数组 不用泛型的话，这个函数可能是下面这样 function createArray(value: any, count: number): any[] &#123; let arr: any[] = []; for (let i = 0; i &lt;= count; i++) &#123; arr.push(value); &#125; return arr;&#125;console.log(createArray(\"aa\", 2));console.log(createArray(2, 2)); 使用泛型 不一定非得用 T function createArray2&lt;T&gt;(value: T, count: number): T[] &#123; let arr: Array&lt;T&gt; = []; for (let i = 0; i &lt;= count; i++) &#123; arr.push(value); &#125; return arr;&#125;console.log(createArray(\"aa\", 2));console.log(createArray(2, 2)); 多个泛型参数的函数 一个函数可以定义多个泛型参数 function swap&lt;A, B&gt;(a: A, b: B): [A, B] &#123; return [a, b];&#125;const res = swap&lt;string, number&gt;(\"tom\", 12);console.log(res); 泛型接口 在定义接口时, 为接口中的属性或方法定义泛型类型在使用接口时, 再指定具体的泛型类型 interface IbaseCRUD&lt;T&gt; &#123; data: T[]; add: (t: T) =&gt; void; getById: (id: number) =&gt; T;&#125;class User &#123; id?: number; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;&#125;class UserCRUD implements IbaseCRUD&lt;User&gt; &#123; data: User[] = []; add(user: User): void &#123; user = &#123; ...User, id: Date.now() &#125;; this.data.push(user); console.log(\"save user\", user.id); &#125; getById(id: number): User &#123; return this.data.find((i) =&gt; i.id === id); &#125;&#125;const userCRUD = new UserCRUD();userCRUD.add(new User(\"tom\", 12));userCRUD.add(new User(\"tom2\", 13));console.log(userCRUD.data); 泛型类 在定义类时, 为类中的属性或方法定义泛型类型 在创建类的实例时, 再指定特定的泛型类型 class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;;let myGenericString = new GenericNumber&lt;string&gt;();myGenericString.zeroValue = \"abc\";myGenericString.add = function (x, y) &#123; return x + y;&#125;;console.log(myGenericString.add(myGenericString.zeroValue, \"test\"));console.log(myGenericNumber.add(myGenericNumber.zeroValue, 12)); 泛型约束 如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性 // 没有泛型约束function fn&lt;T&gt;(x: T): void &#123; // Error: Property 'length' does not exist on type 'T'. // console.log(x.length);&#125;//添加泛型约束实现interface Lengthwise &#123; length: number;&#125;function fn2&lt;T extends Lengthwise&gt;(x: T): void &#123; console.log(x.length);&#125;fn(\"12\");// Error: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.// fn(12)","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"TypeScript 其他","slug":"TypeScript-其他","date":"2019-01-24T07:15:53.000Z","updated":"2022-01-12T07:29:47.983Z","comments":true,"path":"2019/01/24/TypeScript-其他/","link":"","permalink":"http://nicebp.com/2019/01/24/TypeScript-其他/","excerpt":"当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能","text":"当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能 声明文件 declare var 什么是声明语句 假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 &lt;script&gt; 标签引入 jQuery，然后就可以使用全局变量 $或 jQuery 了。 但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西 /** *当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 *声明语句: 如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码 *declare var jQuery: (selector: string) =&gt; any; *声明文件: 把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件 *下载声明文件: npm install @types/jquery --save-dev */jQuery(\"#foo\");// ERROR: Cannot find name 'jQuery'. 这时，我们需要使用 declare var 来定义它的类型 declare var JQuery: (selector: string) =&gt; any;jQuery(\"#foo\"); declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是： jQuery(\"#foo\"); 一般声明文件都会单独写成一个 xxx.d.ts 文件创建 01_jQuery.d.ts, 将声明语句定义其中, TS 编译器会扫描并加载项目中所有的 TS 声明文件 declare var JQuery: (selector: string) =&gt; any; 很多的第三方库都定义了对应的声明文件库, 库文件名一般为 @types/xxx, 可以在 https://www.npmjs.com/package/package 进行搜索有的第三库在下载时就会自动下载对应的声明文件库(比如: webpack),有的可能需要单独下载(比如 jQuery/react) 内置对象 JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 ECMAScript 的内置对象 BooleanNumberStringDateRegExpError /* 1. ECMAScript 的内置对象 */let b: Boolean = new Boolean(1);let n: Number = new Number(true);let s: String = new String(\"abc\");let d: Date = new Date();let r: RegExp = /^1/;let e: Error = new Error(\"error message\");b = true;// let bb: boolean = new Boolean(2) // error BOM 和 DOM 的内置对象 WindowDocumentHTMLElementDocumentFragmentEventNodeList const div: HTMLElement = document.getElementById(\"test\");const divs: NodeList = document.querySelectorAll(\"div\");document.addEventListener(\"click\", (event: MouseEvent) =&gt; &#123; console.dir(event.target);&#125;);const fragment: DocumentFragment = document.createDocumentFragment();","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"TypeScript 函数","slug":"TypeScript-函数","date":"2019-01-23T08:14:16.000Z","updated":"2022-01-12T07:29:47.984Z","comments":true,"path":"2019/01/23/TypeScript-函数/","link":"","permalink":"http://nicebp.com/2019/01/23/TypeScript-函数/","excerpt":"函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用","text":"函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用 基本示例 和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。 // 命名函数function add(x, y) &#123; return x + y;&#125;// 匿名函数const myAdd = function (x, y) &#123; return x + y;&#125;; 函数类型 为函数定义类型为上面函数添加类型 function add(x: number, y: number): number &#123; return x + y;&#125;const myAdd = function (x: number, y: number): number &#123; return x + y;&#125;; 可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型 完整的函数类型const myAdd2: (x: number, y: number) =&gt; number = ( x: number, y: number): number =&gt; &#123; return x + y;&#125;; 可选参数和默认参数 TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。 JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的： 在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把firstName的默认值设置为 &quot;A&quot; function buildName(firstName: string = \"A\", lastName?: string): string &#123; if (lastName) &#123; return firstName + \"-\" + lastName; &#125; else &#123; return firstName; &#125;&#125;console.log(buildName(\"C\", \"D\"));console.log(buildName(\"C\"));console.log(buildName()); 剩余参数必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。 在 TypeScript 里，你可以把所有参数收集到一个变量里：剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ... ）后面给定的名字，你可以在函数体内使用这个数组。与 ES6+ 相同 function info(x: string, ...args: string[]) &#123; console.log(x, args);&#125;info(\"a\", \"b\", \"c\", \"d\"); 函数重载 函数重载: 函数名相同, 而形参不同的多个函数在 JS 中, 由于弱类型的特点和形参与实参可以不匹配, 是没有函数重载这一说的 但在 TS 中, 与其它面向对象的语言(如 Java)就存在此语法 /** * 函数重载： 函数名相同，而入参不同的多个函数 * 需求：有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加 */// 函数重载声明function add(x: string, y: string): string;function add(x: number, y: number): number;// 定义函数实现function add(x: string | number, y: string | number): any &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y if (typeof x === \"string\" &amp;&amp; typeof y === \"string\") &#123; return x + y; &#125; else if (typeof x === \"number\" &amp;&amp; typeof y === \"number\") &#123; return x + y; &#125; // if (&lt;string&gt;x &amp;&amp; &lt;string&gt;y) &#123; // return x + y; // &#125; else if (&lt;number&gt;x &amp;&amp; &lt;number&gt;y) &#123; // return x + y; // &#125;&#125;console.log(add(1, 2));console.log(add(\"a\", \"b\"));// console.log(add(1, 'a')) // error","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"TypeScript 类","slug":"TypeScript-类","date":"2019-01-22T02:27:59.000Z","updated":"2022-01-12T07:29:47.985Z","comments":true,"path":"2019/01/22/TypeScript-类/","link":"","permalink":"http://nicebp.com/2019/01/22/TypeScript-类/","excerpt":"对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。","text":"对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。 类 class /* * 类的基本定义与使用 */class Greeter &#123; // 属性声明 message: string; // 构造函数 constructor(message: string) &#123; this.message = message; &#125; //一般方法 greet(): string &#123; return `Hello $&#123;this.message&#125;`; &#125;&#125;// 创建类实例const greeter = new Greeter(\"world\");// 调用实例方法console.log(greeter.greet()); 如果使用过 C# 或 Java，你会对这种语法非常熟悉。 声明一个 Greeter 类。这个类有 3 个成员：一个叫做 message 的属性，一个构造函数和一个 greet 方法。 你会注意到，在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。 后面一行，使用 new构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。 最后一行通过 greeter 对象调用其 greet 方法 继承 extends 在 TypeScript 里，可以使用常用的面向对象模式。基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 /* * 类的继承 */class Animal &#123; run(distance: number) &#123; console.log(`Animal run $&#123;distance&#125;`); &#125;&#125;class Dog extends Animal &#123; cry() &#123; console.log(\"wang~\"); &#125;&#125;const dog = new Dog();dog.cry();dog.run(100); // 可以调用从父中继承得到的方法 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Dog 是一个 派生类，它派生自 Animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。因为 Dog 继承了 Animal 的功能，因此我们可以创建一个 Dog 的实例，它能够 cry() 和 run() class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; run(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; // 调用父类构造方法 super(name); &#125; // 重写父类方法 run(distance: number = 5) &#123; console.log(\"sliding...\"); // 调用父类型的一般方法 super.run(distance); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; // 调用父类构造方法 super(name); &#125; // 重写父类方法 run(distance: number = 50) &#123; console.log(\"dashing...\"); // 调用父类型的一般方法 super.run(distance); &#125; xxx() &#123; console.log(\"xxx()\"); &#125;&#125;const snake = new Snake(\"sn\");snake.run();const horse = new Horse(\"ho\");horse.run();// 父类型引用指向子类型的实例 ==&gt; 多态const tom: Animal = new Horse(\"tom\");tom.run();// 如果子类没有扩展的方法，可以让子类型引用指向夫类型的实例const jreey: Snake = new Animal(\"jreey\");jreey.run();/* 如果子类型有扩展的方法, 不能让子类型引用指向父类型的实例 */// Error: Property 'xxx' is missing in type 'Animal' but required in type 'Horse'.// const tom2: Horse = new Animal('tom2')// Error: Cannot find name 'tom2'. Did you mean 'tom'?// tom2.run() 这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal 的两个子类：Horse 和 Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。Snake 类和 Horse 类都创建了 run 方法，它们重写了从 Animal 继承来的 run 方法，使得 run 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.run() 时，它会调用 Horse 里重写的方法。 公共，私有与受保护的修饰符 默认为 public上面的例子里，可以自由的访问程序里定义的成员。如果你的其他语言的类比较了解，就会注意到之前的代码里面并没有使用public来做修饰；例如, C# 要求必须明确的使用 public 指定成员是可见的。在 TypeScript 中，成员都默认为 public 可以明确的将一个成员标记成 public ,可以用下面的方式重写上面的 Animal 类 内部私有 private当被标记 pricate ，它就不能在声明它的类的外部访问。 受保护的 protectedprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。 /* * 访问修饰符：用来描述类内部的属性/方法的可访问性 * public: 默认值，公开的外部也可以访问 * private：只能类内部访问 * protected：类内部和子类可以访问 */class Animal &#123; public name: string; public constructor(name: string) &#123; this.name = name; &#125; public run(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`); &#125;&#125;class Person extends Animal &#123; private age: number = 12; protected sex: string = \"Man\"; run(distance: number = 5) &#123; console.log(\"Person jumping...\"); super.run(distance); &#125;&#125;class Student extends Person &#123; run(distance: number = 6) &#123; console.log(\"Student jumping...\"); console.log(this.sex); // 子类能看到父类中受保护的成员 // console.log(this.age); // 子类看不到父类中私有的成员 super.run(distance); &#125;&#125;console.log(new Person(\"tom\").name); //公开可见的// Error: Property 'sex' is protected and only accessible within class 'Person' and its subclasses.// console.log(new Person(\"tom\").sex); // 受保护的不可见// Error: Property 'age' is private and only accessible within class 'Person'.// console.log(new Person(\"tom\").age); // 私有不可见 修饰符 readonly 使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 class Person &#123; readonly name: string = \"tom\"; constructor(name: string) &#123; this.name = name; &#125;&#125;let jerry = new Person(\"jerry\");// Error: Cannot assign to 'name' because it is a read-only property.// jerry.name = \"tony\"; // Error 参数属性在上面的例子中，必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性 class Person2 &#123; constructor(readonly name: string) &#123;&#125;&#125;const p = new Person2(\"jack\");console.log(p.name); 注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样 存取器 getters/setters TypeScript 支持通过 getters/setters来截取对象成员的访问，它能有效帮助你控制对象成员的访问下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。 class Person &#123; firstName: string = \"A\"; lastName: string = \"B\"; get fullName(): string &#123; return this.firstName + \"-\" + this.lastName; &#125; set fullName(value: string) &#123; const names = value.split(\"-\"); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;const p = new Person();console.log(p.fullName);p.firstName = \"C\";p.lastName = \"D\";console.log(p.fullName);p.fullName = \"E-F\";console.log(p.firstName, p.lastName); 静态属性 static 到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 Person.origin 来访问静态属性。 /** * 静态属性，是类对象的属性 * 非静态属性，是类实例对象的属性 */class Person &#123; name: string = \"A\"; static origin: string = \"B\";&#125;console.log(Person.origin);console.log(new Person().name); 抽象类 abstract 抽象类做为其它派生类的基类使用。 它们不能被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。 /** * 抽象类 * 不能创建实例对象，只有实现类才能创建实例 * 可以包含未实现的抽象方法 */abstract class Animal &#123; abstract cry(): void; run() &#123; console.log(\"run()\"); &#125;&#125;class Tom extends Animal &#123; cry() &#123; console.log(\"Tom cry()\"); &#125;&#125;const tom = new Tom();tom.cry();tom.run();","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"TypeScript 接口","slug":"TypeScript-接口","date":"2019-01-21T08:47:26.000Z","updated":"2022-01-12T07:29:47.984Z","comments":true,"path":"2019/01/21/TypeScript-接口/","link":"","permalink":"http://nicebp.com/2019/01/21/TypeScript-接口/","excerpt":"TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)","text":"TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述) 接口 interface /* 在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型接口: 是对象的状态(属性)和行为(方法)的抽象(描述)接口类型的对象 多了或者少了属性是不允许的 可选属性: ? 只读属性: readonly*//* 需求: 创建人的对象, 需要对人的属性进行一定的约束 id是number类型, 必须有, 只读的 name是string类型, 必须有 age是number类型, 必须有 sex是string类型, 可以没有*/// 定义人的接口interface IPerson &#123; id: number; name: string; age: number; sex: string;&#125;const person1: IPerson = &#123; id: 1, name: \"tom\", age: 20, sex: \"男\",&#125;; 类型检查器会查看对象内部的属性是否与 IPerson 接口描述一致, 如果不一致就会提示类型错误。 可选属性 ? 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 interface IPerson &#123; id: number; name: string; age: number; sex?: string;&#125; 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 const person2: IPerson = &#123; id: 1, name: \"tom\", age: 20, // sex: '男' // 可以没有&#125;; 只读属性 readonly 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性 interface IPerson &#123; readonly id: number; name: string; age: number; sex?: string;&#125; 一旦赋值后再也不能被改变了。 const person2: IPerson = &#123; id: 2, name: \"tom\", age: 20, // sex: '男' // 可以没有 // xxx: 12 // error 没有在接口中定义, 不能有&#125;;person2.id = 2; // error readonly vs const最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly 函数类型 接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 /* 接口可以描述函数类型(参数的类型与返回的类型)*/interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量 const mySearch: SearchFunc = function (source: string, sub: string): boolean &#123; return source.search(sub) &gt; -1;&#125;;console.log(mySearch(\"abcd\", \"bc\")); 类类型 类实现接口与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约 /* 类类型: 实现接口1. 一个类可以实现多个接口2. 一个接口可以继承多个接口*/interface Alarm &#123; alert(): any;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm &#123; alert() &#123; console.log(\"Car alert\"); &#125;&#125; 一个类可以实现多个接口class Car2 implements Alarm, Light &#123; alert() &#123; console.log(\"Car alert\"); &#125; lightOn() &#123; console.log(\"Car light on\"); &#125; lightOff() &#123; console.log(\"Car light off\"); &#125;&#125; 接口继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 interface LightableAlarm extends Alarm, Light &#123;&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"TypeScript 基础类型","slug":"TypeScript-基础类型","date":"2019-01-20T07:01:55.000Z","updated":"2022-01-12T07:29:47.984Z","comments":true,"path":"2019/01/20/TypeScript-基础类型/","link":"","permalink":"http://nicebp.com/2019/01/20/TypeScript-基础类型/","excerpt":"TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。","text":"TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值 boolean 最基本的数据类型就是简单的 true/false 值，在 JavaScript 和 TypeScript 里叫做 boolean（其它语言中也一样）。 let isDone: boolean = false;isDone = true;// isDone = 2 // error 数字 number 和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。 let a1: number = 10; // 十进制let a2: number = 0b1010; // 二进制let a3: number = 0o12; // 八进制let a4: number = 0xa; // 十六进制 字符串 string JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（”）或单引号（’）表示字符串。 let name: string = \"Tom\";name = \"jreey\";// name = 10 //error undefined 和 null TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 它们的本身的类型用处不是很大默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 let u: undefined = undefined;let n: null = null; 数组 array TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： let arr1: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： let arr2: Array&lt;number&gt; = [1, 2, 3];let arr3: Array&lt;string&gt; = [\"1\", \"2\", \"3\"]; 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 let t = [string, number];t = [\"tom\", 10]; // successt = [10, \"tom\"]; // error 当访问一个已知索引的元素，会得到正确的类型： console.log(t[0].substring(1)); // successconsole.log(t[1].substring(1)); // error, 'number' 不存在 'substring' 方法 枚举 enum enum 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字 enum Color &#123; red, green, blue,&#125;// 枚举数值默认从0开始依次递增// 根据特定的名称得到对应的枚举数值let myColor: Color = Color.red; // 0console.log(myColor, Color.red, Color.blue); 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： enum Color &#123; red = 1, green, blue,&#125;let c: Color = Color.green; 或者，全部都采用手动赋值： enum Color &#123; red = 1, green = 2, blue = 4,&#125;let c: Color = Color.green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字： enum Color &#123; red = 1, green, blue,&#125;let colorName: string = Color[2];console.log(colorName); // \"green\" any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： let txt: any = 12;txt = \"tom\";txt = true; // 也可以是个 boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, \"tom\"];list[1] = 12; void 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void /* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */function fn(): void &#123; console.log(\"fn()\"); // return undefined // return null // return 1 // error&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null let unusable: void = undefined; objectobject 表示非原始类型，也就是除 number，string，boolean 之外的类型。使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如： function fn2(obj: object): object &#123; console.log(\"fn2()\", obj); return &#123;&#125;; // return undefined // return null&#125;console.log(fn2(new String(\"abc\")));// console.log(fn2('abc') // errorconsole.log(fn2(String)); 联合类型 Union Types联合类型（Union Types）表示取值可以为多种类型中的一种需求 1: 定义一个一个函数得到一个数字或字符串值的字符串形式值 function toString2(x: number | string): string &#123; return x.toString();&#125; 需求 2: 定义一个一个函数得到一个数字或字符串值的长度 function getLength(x: number | string) &#123; // return x.length // error if (x.length) &#123; // error return x.length; &#125; else &#123; return x.toString().length; &#125;&#125; 类型断言 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法 /* 类型断言(Type Assertion): 可以用来手动指定一个值的类型语法: 方式一: &lt;类型&gt;值 方式二: 值 as 类型 tsx中只能用这种方式*//* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */function getLength(x: number | string) &#123; if ((&lt;string&gt;x).length) &#123; return (x as string).length; &#125; else &#123; return x.toString().length; &#125;&#125;console.log(getLength(\"abcd\"), getLength(1234)); 类型推断 类型推断: TS 会在没有明确的指定类型的时候推测出一个类型有下面 2 种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为 any 类型 /* 定义变量时赋值了, 推断为对应的类型 */let b9 = 123; // number// b9 = 'abc' // error/* 定义变量时没有赋值, 推断为any类型 */let b10; // any类型b10 = 123;b10 = \"abc\";","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://nicebp.com/tags/TypeScript/"}]},{"title":"ESLint&VSCode自动化配置","slug":"ESLint-VSCode自动化配置","date":"2018-02-22T03:47:23.000Z","updated":"2022-01-12T07:29:47.982Z","comments":true,"path":"2018/02/22/ESLint-VSCode自动化配置/","link":"","permalink":"http://nicebp.com/2018/02/22/ESLint-VSCode自动化配置/","excerpt":"eslint 配合 vscode 一劳永逸的处理办法","text":"eslint 配合 vscode 一劳永逸的处理办法 VS Code 插件ESLintVeturPrettier - Code formatter VS Code Settings 相关设置&#123; //制表符符号eslint \"editor.tabSize\": 2, // 每次保存的时候自动格式化 \"editor.formatOnSave\": true, // 每次保存的时候将代码按eslint格式进行修复 \"eslint.autoFixOnSave\": true, // 添加 vue 支持 \"eslint.validate\": [ \"javascript\", &#123; \"language\": \"vue\", \"autoFix\": true &#125;, \"html\", \"vue\" ], //eslint 选项 \"eslint.options\": &#123; \"extensions\": [\".js\", \".vue\"] &#125;, //让prettier使用eslint的代码格式进行校验 \"prettier.eslintIntegration\": true, //去掉代码结尾的分号 \"prettier.semi\": false, //使用带引号替代双引号 \"prettier.singleQuote\": true, //让函数(名)和后面的括号之间加个空格 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, //格式化.vue中html \"vetur.format.defaultFormatter.html\": \"js-beautify-html\",&#125; 项目 package.json 中安装 eslint 相关依赖\"eslint\": \"^4.19.1\",\"eslint-friendly-formatter\": \"^4.0.1\",\"eslint-loader\": \"^2.0.0\",\"eslint-plugin-html\": \"^4.0.3\", npm 安装方法npm install eslint -gornpm install eslint --dev","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[]},{"title":"H5竖屏下横屏显示","slug":"H5竖屏下横屏显示","date":"2017-10-22T03:47:23.000Z","updated":"2022-01-12T07:29:47.982Z","comments":true,"path":"2017/10/22/H5竖屏下横屏显示/","link":"","permalink":"http://nicebp.com/2017/10/22/H5竖屏下横屏显示/","excerpt":"有一天经理说：哎~那个谁，咱这个页面能不能做成，竖屏横着显示，横屏也横这显示的…","text":"有一天经理说：哎~那个谁，咱这个页面能不能做成，竖屏横着显示，横屏也横这显示的… 想一想大概的实现思路是这样的 选取一个 dom 节点比如 body ; css 赋值宽等于实际的高，高等于实际的宽; 利用 css3 transform rotate 属性选转90度; js 监听 onorientationchange 旋转控制样式; 核心css 测试机型 iphone6/7/8 375*667 body&#123; width: 667px; height: 375px; transform: rotate(90deg); transform-origin: 0px 0px 0px; margin: 0px 0px 0px 375px; padding: 0px;&#125; 核心js主要是赋予 dom 节点 css 宽高，监听屏幕旋转做不同的样式更换 //竖屏默认横屏显示if ($('body').width() &lt; $('body').height()) &#123; $('body').css(&#123; 'width': $('body').height(), 'height': $('body').width(), 'transform': 'rotate(90deg)', 'transform-origin': '0px 0px 0px', 'margin': '0', 'margin-left': $('body').width(), 'padding': '0' &#125;)&#125; else &#123; $('body').attr('style', '')&#125;; //转屏控制window.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", function () &#123; if (window.orientation === 180 || window.orientation === 0) &#123; //设备竖屏状态 $('body').css(&#123; 'width': $('body').width(), 'height': $('body').height(), 'transform': 'rotate(90deg)', 'transform-origin': '0px 0px 0px', 'margin': '0', 'margin-left': $('body').height(), 'padding': '0' &#125;) &#125; if (window.orientation === 90 || window.orientation === -90) &#123; //设备横屏状态 $('body').attr('style', '') &#125;&#125;, false);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[]},{"title":"Chrome 跨域设置","slug":"Chrome-跨域设置","date":"2017-10-09T09:35:35.000Z","updated":"2022-01-12T07:29:47.982Z","comments":true,"path":"2017/10/09/Chrome-跨域设置/","link":"","permalink":"http://nicebp.com/2017/10/09/Chrome-跨域设置/","excerpt":"利用 --disable-web-security 参数，这个参数可以降低Chrome的安全性，禁止同源策略，方便本地开发调试","text":"利用 --disable-web-security 参数，这个参数可以降低Chrome的安全性，禁止同源策略，方便本地开发调试 1.在 C:\\ 中新建 MyChromeDevUserData 文件用来储存个人信息，不在使用默认目录2.新建一个Chrome快捷方式，在其属性目标位置...\\chrome.exe&quot;后添加 --disable-web-security --user-data-dir=C:\\MyChromeDevUserData 注意--之前必须要有一个空格 3.关闭属性面板,打开chrome浏览器，会看到 --disable-web-security 安全性提示，说明Chrome可以跨域工作了","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[]},{"title":"VS Code 添加右键快捷打开方式","slug":"VS-Code-添加右键快捷打开方式","date":"2017-09-29T06:35:35.000Z","updated":"2022-01-12T07:29:47.985Z","comments":true,"path":"2017/09/29/VS-Code-添加右键快捷打开方式/","link":"","permalink":"http://nicebp.com/2017/09/29/VS-Code-添加右键快捷打开方式/","excerpt":"Windows软件编辑器及阅读软件，安装后没有出现在右键快捷菜单中使用极为不便，以Visual Studio Code为例添加右键快捷打开方式，快速打开文件及文件夹","text":"Windows软件编辑器及阅读软件，安装后没有出现在右键快捷菜单中使用极为不便，以Visual Studio Code为例添加右键快捷打开方式，快速打开文件及文件夹 快速打开文件1. Win+R 输入 regedit 打开运行注册表 2. 打开注册表找到 HKEY_CLASSES_ROOT\\*\\shell 分支右键新建项 Open with VSCode (名字随意) 3. 在右侧窗口的“默认”键值栏内输入open with VS Code，这是单击鼠标右键时VisualCode启动程序的显示值。项的名称和键值可以任意，以含义明确为好。其中键值将显示在右键菜单中。新建字符串值Icon值 为软件的安装路径如下图： 4. 在 Open with VSCode 文件下新建 Command 项，在右侧窗口的“默认”键值栏内输入程序所在的路径 如：D:\\sort\\Microsoft VS Code\\Code.exe %1 其中的%1表示要打开的文件参数。 5. 关闭注册表即刻生效 快速打开文件夹1. 打开注册表找到 HKEY_CLASSES_ROOT\\Directory\\shell 新建项 Open with VSCode 在其下新建字符串值 Icon 值为软件安装路径如图： 2. 在 Open with VSCode 文件下新建 Command 项 设置值为软件安装路径 如：D:\\sort\\Microsoft VS Code\\Code.exe %1 3.关闭注册表即刻生效","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[]},{"title":"徐松","slug":"徐松","date":"2017-08-15T08:38:44.000Z","updated":"2022-01-12T07:29:47.987Z","comments":true,"path":"2017/08/15/徐松/","link":"","permalink":"http://nicebp.com/2017/08/15/徐松/","excerpt":"朋友&amp;新车","text":"朋友&amp;新车 2016 年 11 月份朋友刚买了新车没有上牌，兴冲冲拉着一起去海边狂飙，路过一处不错的海滩，索性拍了一组照片","categories":[{"name":"照片","slug":"照片","permalink":"http://nicebp.com/categories/照片/"}],"tags":[{"name":"照片","slug":"照片","permalink":"http://nicebp.com/tags/照片/"}]},{"title":"Visual Studio Code常用快捷键","slug":"Visual-Studio-Code常用快捷键","date":"2017-07-12T02:20:58.000Z","updated":"2022-01-12T07:29:47.985Z","comments":true,"path":"2017/07/12/Visual-Studio-Code常用快捷键/","link":"","permalink":"http://nicebp.com/2017/07/12/Visual-Studio-Code常用快捷键/","excerpt":"Visual Studio Code 常用快捷键整理","text":"Visual Studio Code 常用快捷键整理 基础编辑 快捷键 描述 Ctrl + C 复制 Ctrl + V 粘贴 Ctrl + X 剪贴 Alt + Up/Down 移动上下行 Shift + Alt + Up/Down 在当前行上下复制当前行 Shift + Ctrl + K 删除当前行 Ctrl + Enter 在当前行下插入新的一行 Ctrl + I 选中当前行 Ctrl + Shift + Enter 在当前行上插入新的一行 Ctrl + Shift + &#124; 匹配括号闭合处跳转 Ctrl + ]/[ 行缩进 Ctrl + Up/Down 行视图上下移动 Ctrl + Shift + Up/Down 从当前行开始向上或向下连续选中 Alt + Up/Down 当前行向上向下移动 Ctrl + / 添加删除行注释 Shift + Alt + A 块区域注释 Ctrl + Shift + [ 折叠区域代码 Ctrl + Shift + ] 展开区域代码","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[]},{"title":"新玩具 hexo","slug":"新玩具-hexo","date":"2017-07-06T03:05:39.000Z","updated":"2022-01-12T07:29:47.987Z","comments":true,"path":"2017/07/06/新玩具-hexo/","link":"","permalink":"http://nicebp.com/2017/07/06/新玩具-hexo/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 常用功能 hexo 新建文章hexo new \"文章标题\" hexo 新建页面hexo new page \"页面标题\" hexo 清除缓存hexo clean hexo 生成静态文件hexo generate hexo 发布文章hexo deploy -g hexo 草稿hexo publish [layout] &lt;title&gt; hexo 服务器运行hexo server","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://nicebp.com/tags/Hexo/"}]},{"title":"Markdown简要使用说明","slug":"Markdown使用说明","date":"2017-07-05T03:47:19.000Z","updated":"2022-01-12T07:29:47.983Z","comments":true,"path":"2017/07/05/Markdown使用说明/","link":"","permalink":"http://nicebp.com/2017/07/05/Markdown使用说明/","excerpt":"Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以","text":"Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 目录 基础用法 斜体和粗体 分级标题 外链接 无序列表 有序列表 文字引用 行内代码块 代码块 插入图片 Todo 列表 绘制表格 公式 分割线 删除线 转义符号 1.斜体和粗体*斜体* **粗体** 斜体 粗体 2.分级标题# == H1## == H2### == H3#### == H4##### == H5###### == H6 一级标题二级标题三级标题四级标题五级标题六级标题 3.外链接[描述](URL) 本人博客 4.无序列表* + - 均可表示无序列表 无序列表 无序列表 无序列表 5.有序列表使用 数字和. 有序列表项 一 有序列表项 二 有序列表项 三 6.文字引用&gt; 引用的文字 引用的文字 7.行内代码块`alert('Hello World')` alert(&#39;Hello World&#39;) 8.代码块 使用连续三个 ` 符号，闭合同样使用连续三个 Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125;var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];alert(arr.unique3()); 9.插入图片![描述](URL) 10.Todo 列表- [x] 早起- [x] 吃早饭- [ ] 赶地铁- [ ] COC- [ ] 上班 早起 吃早饭 赶地铁 COC 上班 11.绘制表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 12.书写一个能量守恒公式$$E=mc^2$$ $$E=mc^2$$ 13.分割线连续三个 *或- *** --- 14.删除线~~删除的内容~~ 删除的内容 15.转义符号 使用 \\ 反斜杠可以禁止转义","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://nicebp.com/tags/markdown/"}]},{"title":"利用 Visual Studio Code 打造高逼格编辑器","slug":"利用-Visual-Studio-Code-打造高逼格编辑器","date":"2017-06-09T07:16:19.000Z","updated":"2022-01-12T07:29:47.986Z","comments":true,"path":"2017/06/09/利用-Visual-Studio-Code-打造高逼格编辑器/","link":"","permalink":"http://nicebp.com/2017/06/09/利用-Visual-Studio-Code-打造高逼格编辑器/","excerpt":"推荐几款vs code不错的插件主题","text":"推荐几款vs code不错的插件主题 主题 Andromeda 主题 Snazzy Operator 插件 Windows opacity 插件 Open-In-Browser 插件 CSS Peek 插件 Minify","categories":[],"tags":[]},{"title":"web前端判断竖屏横屏","slug":"web前端判断竖屏横屏","date":"2017-04-27T09:10:41.000Z","updated":"2022-01-12T07:29:47.986Z","comments":true,"path":"2017/04/27/web前端判断竖屏横屏/","link":"","permalink":"http://nicebp.com/2017/04/27/web前端判断竖屏横屏/","excerpt":"web前端在移动手持设备中判断横竖屏的几种方式","text":"web前端在移动手持设备中判断横竖屏的几种方式 如果设备横竖屏切换被系统锁掉的话，你怎么搞都是切换不了的 如果页面viewport是经过缩放的可能会导致 CSS3 @media 判断失效 CSS3 @media媒体查询判断@media screen and (orientation:portrait)&#123; /* 竖屏 css */&#125;@media screen and (orientation:landscape)&#123; /* 横屏 css */&#125; PS:使用CSS3 @media方式做判断需要注意viewport必须是未经适配缩放的如下↓↓↓&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"/&gt; HTML link标签分别引用&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt;&lt;!-- 横屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"landscape.css\"&gt; Javascript onorientationchange事件判断//判断手机横竖屏状态：window.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", function() &#123; if (window.orientation === 180 || window.orientation === 0) &#123; //竖屏 &#125; if (window.orientation === 90 || window.orientation === -90 )&#123; //横屏 &#125; &#125;, false); PS:如果还是解决不了问题，可以尝试一下 orientationchange-fix，是针对orientationchange事件不兼容进行的修复","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[{"name":"html5+css3","slug":"html5-css3","permalink":"http://nicebp.com/tags/html5-css3/"}]},{"title":"HTML中常见的<mate>标签","slug":"HTML中常见的-mate-标签","date":"2017-03-09T03:53:48.000Z","updated":"2022-01-12T07:29:47.983Z","comments":true,"path":"2017/03/09/HTML中常见的-mate-标签/","link":"","permalink":"http://nicebp.com/2017/03/09/HTML中常见的-mate-标签/","excerpt":"HTML中常见不常见的 &lt;mate&gt;标签","text":"HTML中常见不常见的 &lt;mate&gt;标签 在编写代码的时候经常会有个别一时想不起来，索性记录一下网页编码&lt;meta charset=\"UTF-8\"&gt; 网页自适应&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 以最新内核加载&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge, chrome=1\"&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt; 禁止识别邮箱电话号码&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt;&lt;meta content=\"email=no\" name=\"format-detection\" /&gt; 禁止浏览器读取缓存&lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt; 关键词&lt;meta name=\"keywords\" content=\"KEYWORD1,KEYWORD2,KEYWORD3\"&gt; 网页描述&lt;meta name=\"description\" itemprop=\"description\" content=\"DESCRIPTION\"&gt; 作者信息&lt;meta name=\"author\"content=\"Shaw,519208248@qq.com\"&gt; 避免IE使用兼容模式&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; 启用360浏览器的极速模式(webkit)&lt;meta name=\"renderer\" content=\"webkit\"&gt; 网页小图标&lt;link rel=\"icon\" type=\"image/ico\" href=\"favico.ico\"&gt; Ios设备&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 是否启用 WebApp 全屏模式 --&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;!-- 设置状态栏的背景颜色，只有在 \"apple-mobile-web-app-capable\" content=\"yes\" 时生效 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\" /&gt; &lt;!-- iPad，72x72 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"72x72\" href=\"/apple-touch-icon-72x72-precomposed.png\" /&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\" /&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\" /&gt; content 参数： default 默认值 black 状态栏背景是黑色 black-translucent 状态栏背景是黑色半透明 Android 主题颜色&lt;meta name=\"theme-color\" content=\"#db5945\"&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[{"name":"html5+css3","slug":"html5-css3","permalink":"http://nicebp.com/tags/html5-css3/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2017-02-08T10:34:14.000Z","updated":"2022-01-12T07:29:47.986Z","comments":true,"path":"2017/02/08/git常用命令/","link":"","permalink":"http://nicebp.com/2017/02/08/git常用命令/","excerpt":"git 常用命令","text":"git 常用命令 查看本机 SHH keycat ~/.ssh/id_rsa.pub 创建 SSH key$ ssh-keygen -t rsa -C \"youremail@example.com\" 配置全局 name 和 email$ git config --global user.name \"yourname\" $ git config --global user.email \"yourname@example.com\" git仓库初始化$ git init 克隆项目$ git clone URL 查看状态$ git status 添加文件$ git add . 本地提交$ git commit -m \"描述\" 查看远程仓库地址$ git remote -v 添加远程地址$ git remote add origin URL 提交到远程仓库$ git push -u origin master 查看远程分支$ git branch -a 查看本地分支$ git branch 创建分支$ git branch branch name 切换到分支$ git checkout branch name 新建本地分支$ git checkout -b branch 将新建的分支push到远程服务器$ git push origin branch:branch 远程分支与本地分支同名（当然可以随意起名） 删除远程分支# 直接push过去一个空分支到远程，相当于删除远程分支$ git push origin :branch# 直接删除$ git push origin --delete branch 修改远程仓库地址 通过命令直接修改 $ git remote set-url origin https://github.com/YOUNAME/ITEMNAME.git 通过命令先删除后添加 $ git remote -v$ git remote rm origin $ git remote add origin https://github.com/YOUNAME/ITEMNAME.git 当本地分支没有和远程分支没有建立联系的时候 使用 git branch -vv 可以查看本地分支和远程分支的关联关系 $ git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字","categories":[{"name":"笔记","slug":"笔记","permalink":"http://nicebp.com/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"http://nicebp.com/tags/git/"}]}]}